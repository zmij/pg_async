Release notes for PStreams 0.48
===============================

This release includes changes to allow PStreams to be used with G++ 3.4,
which is far more standards compliant that previous releases and caught
several bugs in the code. Let me know if you have any problems.

I've removed the rpstream.h header and moved the definition of the
redi::rpstream class into pstream.h. This is now the only file needed.
Please ensure you remove any copies of rpstream.h from your system if
you're using this release.

Fixed a 64-bit bug where int was compared to a pointer.

The redi::peof IO manipulator now uses dynamic_cast not static_cast.
This is safer, but if you don't want to use dynamic_cast you'll have to
change it back to using static_cast.

Use POSIX's ::_exit() instead of std::exit() to terminate child if exec()
fails. This will prevent static destructors being run in the child process
(which could try to destroy resources twice).

I've also changed the macro that guards the pstream.h header from being
included multiple times, by appending "_SEEN" to the names. If this
causes any problems make sure you dont have any old versions of pstream.h
on your system.

This release has been long overdue and it shouldn't be as long before the
next one. I have some good suggestions to incorporate.

Thanks to everyone who suggested fixes and improvements, or just got
in touch to say they were using the code.

Jon Wakely


PStreams
========

This is the README file for PStreams, a C++ utility for simple IOStream-based
Inter-Process Communication. PStreams is a tool. Not the most efficient or
flexible method of IPC, but fairly simple and IOStream-based, with all the
advantages that provides. I hope you find it useful.

The latest version can be found at http://pstreams.sourceforge.net/
The author can be contacted at pstreams@kayari.org

To use the PStreams classes copy the required header files to somewhere
your compiler can find them and #include them. The headers are commented
so that API documentation to be generated using Doxygen
(http://www.doxygen.org/)

This file contains some notes on PStreams, but is very incomplete. There may
be some notes here that aren't covered in the API documentation, but see
those docs for most questions about usage (or at least, how things _should_
work).

PStreams has only been tested with gcc so far, if you have problems (or
better still - solutions) with PStreams and other compilers please let
me know.

To run the test program compile and run test_pstreams.cc
This can be done with "make test_pstreams" if you have GNU or BSD make
The Makefile doesn't work with Solaris make, and probably other versions
of make.


The PStream Buffer class
============================
The pstreambuf used by the PStreams classes buffers all reads and writes
as of version 0.42 (released 2002-12-03).


Signalling and Termination
==========================
The pstreambuf class now provides a kill(int) member function which is
similar to the C library call and allows signals to be sent to the child.
The stream buffer class also provides an exited() member which will return
true if the child process has terminated, and a status() member which returns
the exit status of the child. This exit status can be evaluated using
the WIFEXITED() and related macros as with the C library function waitpid().


The Good, the Bad and the Ugly
==============================
PStreams is intended to be a clean design based on the standard IOStreams,
but first and foremost it's a handy little tool, and so should be as useful
as possible. Because it is not always possible to redesign a program to use
IOStreams instead of C-style I/O it is possible to expose some internal
details of the PStreams classes. If the macro REDI_EVISCERATE_PSTREAMS has
a non-zero value then the following public method is added to each stream
class:

pmode fopen(FILE*& in, FILE*& out, FILE*& err);

    Obtains FILE pointers relating to each open pipe to the process and
    assigns them to the corresponding FILE* parameters.

These functions should be used with caution because mixing C++ and C I/O
on the same stream may cause problems. The caller should be aware of the
issues involved in using the stream buffer's FILE pointer (see your system's
docs for the fdopen() function that is used by the pstreambuf).
The fdopen() call to obtain a FILE* sets errno to ESPIPE because fdopen()
tries to lseek() on the stream, which is not supported on pipes. This error
is expected and does not cause a problem, so errno is set to zero before
returning from pstreambuf::fopen().


$Id: README,v 1.11 2004/04/30 19:30:27 redi Exp $

