<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html>
<head>
  <!-- $Id: pstreams.html,v 1.7 2002/01/27 12:36:18 redi Exp $ -->
  <title>Redi PStreams Library</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name='description' content='PStreams - A C++ IOStream interface to POSIX Process I/O'>
  <meta name='keywords' content='pstreams, pstream, c++, popen, pclose, posix, process I/O, ipstream, opstream, iostream, iostreams, procbuf, pfstream'>
  <style type='text/css'>
    address { font-style: italic; font-size: smaller; }
    img { border: 0; }
    p { text-align: justify; }
    .note { font-style: italic; font-size: smaller; }
    .right { float: right; }
  </style>
</head>
<body>
<div><a name='top'></a></div>
<table width='100%'>
<tbody>
<tr>
<td>
<h1>PStreams Library</h1>
<p>A C++ IOStream interface to POSIX Process I/O.</p>
</td>
<td align='right'>
<img src='images/pstreams1.png' alt=''>
</td>
</tr>
</tbody>
</table>
<p>The library is a work in progress. When (or rather, if) finished it will
provide a C++ interface to the POSIX.2 functions <code>popen(3)</code> and
<code>pclose(3)</code>,<a href='#footnote1' class='ref'>[1]</a>
using IOStreams to read from or write to the opened process.</p>
<p>The inspiration for this project came from seeing a
<!-- a href='http://gcc.gnu.org/ml/libstdc++/2001-11/msg00107.html' -->message<!-- /a -->
on the <a href='http://gcc.gnu.org/libstdc++/'>libstdc++-v3</a> mailing list
asking what had happened to the <code>pfstream</code> classes that came
with libstdc++-v2.
Because I'd used a similar C++ wrapper for <code>popen()</code> where I work,
and because I want to learn about Standard IOStreams, I decided to try to
write a solution that would work with standard-conforming C++ libraries.
(The <code>pfstream</code> classes were based on the old AT&amp;T style
streams and relied on <a href='http://gcc.gnu.org/'>GCC</a>-specific
libraries.)</p>
<p>My aim is to provide class templates in the style of the standard IOStreams
that can be used with any standard-conforming compiler on a POSIX platform.
This will involve writing a <code>streambuf</code> class that uses the
<code>FILE*</code> returned by <code>popen()</code>.
This may take me a while, so initially the library will only work
on certain versions of GCC (if at all!) and will have no support for
character traits or wide characters.</p>
<!-- TODO update above text, mention erripstreams -->
<p>The library is available under the <a href='http://www.gnu.org/'>GNU</a>
<a href='http://www.gnu.org/licenses/gpl.txt'>General Public License</a>
<p>&nbsp;</p>
<h2><a name='status'>Current status</a></h2>
<p>Version 0.16</p>
<p>Working <code>ipstream</code> and <code>opstream</code> classes for
ISO C++-compliant compilers.
<code>pstream</code> class for systems known to use a bidirectional pipe
to implement <code>popen()</code>.<a href='#footnote2' class='ref'>[2]</a></p>
<p>I am currently working on a new implementation of the stream buffer class,
<code>pstreambuf</code>, that doesn't use <code>popen()</code>. The stream
buffer uses up to three pipes shared with the associated process, giving
access to any combination of the process' <code>stdin</code>,
 <code>stdout</code> and <code>stderr</code> streams.</p>
<p>For non-ISO C++-compliant compilers there are alternative versions of
all classes.
These use non-standard extensions found in the old streams
(such as attaching an <code>fstream</code>'s buffer to a file descriptor with
<code>fstreambase::attach(int fd)</code>) that may not be available on some
systems.
For GCC 2.7/2.8/2.9x/egcs these classes are functional, but are
implemented using <code>fstream</code> and provide no more functionality
than the <code>pfstream</code> classes provided with libg++.
For all other compilers these classes have never even been compiled, let
alone tested, so use them at your own risk.
<br />The non-compliant versions can be used by defining
<code>BACK_COMPAT</code> (or <code>GCC_BACK_COMPAT</code> for the libg++
versions) to be <code>1</code>.
<br />Instantiating the backward-compatible <code>ipstream</code> or
<code>opstream</code>
currently sets <code>errno</code> to <code>ESPIPE</code> because the
<code>fstreambase</code> tries to seek to the end of the stream, which
is not allowed for pipes. <code>errno</code> is reset by the classes.</p>
<p>&nbsp;</p>
<h2><a name='usage'>Usage</a></h2>
<p class='note'>This section is out of date. Please use the doxygen-generated
documentation, accessible through the links at the top of the page.</p>
<p>The PStreams classes have a common public interface.
<code>ipstream</code> is shown here, but <code>opstream</code> is the same
(as is <code>pstream</code> where available).</p>
<pre><code>
class ipstream {
public:
    ipstream();
    ipstream(const std::string&amp; command);
    void open(const std::string&amp; command);
};
</code>
<code>ipstream();</code>
    Creates a new object with no associated process.

<code>ipstream(const std::string&amp; command);</code>
    Passes command to /bin/sh and opens a pipe to the new process.

<code>void open(const std::string&amp; command);</code>
     Passes command to /bin/sh and opens a pipe to the new process.
</pre>
<p>The  command  argument  is  a pointer to a null-terminated
string containing a shell command line.  This  command  is
passed  to  /bin/sh  using the -c flag; interpretation, if
any, is performed by the shell.</p>
<p>Using the PStreams classes is similar to using a <code>std::fstream</code>,
except that a shell command is given rather than a filename:</p>
<pre><code>
// print names of all header files in current directory
redi::ipstream in("/bin/ls ./*.h");
std::string str;
while (in &gt;&gt; str) {
    std::cout &lt;&lt; str &lt;&lt; std::endl;
}
</code></pre>
<p>Note that the PStreams classes do not do any buffering, because the
stream returned by <code>popen()</code> is buffered by the OS by default.
This means that a call to <code>fwrite(3)</code> or <code>fread(3)</code>
is made for every character, I don't know whether this is very efficient.</p>

<p>&nbsp;</p>
<h2><a name='download'>Download</a></h2>
<p>The "library" currently consists of a single header file,
<a href='pstream.h'>pstream.h</a>, which defines the PStreams classes
in the <code>redi</code> namespace.</p>
<p><a href='#top'>top</a></p>
<hr>
<p class='note'><a name='footnote1'>[1]</a> Implementations of
<code>popen()</code> and <code>pclose()</code> vary slightly between systems.
Some systems use bidirectional pipes, allowing reading and writing on the
same stream, but this is not supported everywhere.
Check your local documentation for details of return types and errors.
The 4.3 BSD implementation seems to be fairly typical, you can read the
<a href='http://www.freebsd.org/cgi/man.cgi?query=popen&amp;apropos=0&amp;sektion=3&amp;manpath=4.3BSD+NET%2F2&amp;format=html'>man page</a>
at www.FreeBSD.org</p>
<!-- TODO find POSIX spec of popen -->
<p class='note'><a name='footnote2'>[2]</a> The <code>pstream</code> class
is currently available on FreeBSD version 3 and above and
NetBSD version 1.4 and above.</p>
<p><a href='#top'>top</a></p>
<hr>
<address>
<p>Please send comments, suggestions, bugfixes, patches, cakes, pies etc. to
pstreams&nbsp;at&nbsp;redi&nbsp;dot&nbsp;uklinux&nbsp;dot&nbsp;net
<br />This page last updated on $Date: 2002/01/27 12:36:18 $
<br />Copyright &copy; 2001 Jonathan Wakely</p>
</address>
<p>
<a href="http://validator.w3.org/check/referer"><img
  src="http://www.w3.org/Icons/valid-html40"
  alt="Valid HTML 4.0!" height="31" width="88"></a>
<a href="http://jigsaw.w3.org/css-validator/"><img
  style="border:0;width:88px;height:31px"
  src="http://jigsaw.w3.org/css-validator/images/vcss" 
  alt="Valid CSS!"></a>
</p>
</body>
</html>

