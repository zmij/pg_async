
<!-- start of included file -->

<!-- $Id: pstreams.html,v 1.8 2002/04/20 20:33:52 redi Exp $ -->

<div><a name='top'></a></div>
<table width='100%'>
<tbody>
<tr>
<td>
<h3>A C++ IOStream interface to POSIX Process I/O.</h3>
</td>
<td align='right'>
<img src='images/pstreams1.png' alt=''>
</td>
</tr>
</tbody>
</table>
<p>The library is a work in progress. It is intended to provide a C++
re-implementation of the POSIX.2 functions <code>popen(3)</code> and
<code>pclose(3)</code>, using IOStreams to read from and write to the
opened process.</p>
<p>The inspiration for this project came from seeing a
<!-- a href='http://gcc.gnu.org/ml/libstdc++/2001-11/msg00107.html' -->message<!-- /a -->
on the <a href='http://gcc.gnu.org/libstdc++/'>libstdc++-v3</a> mailing list
asking what had happened to the <code>pfstream</code> classes that came
with libstdc++-v2.
Because I'd used a similar C++ wrapper for <code>popen()</code> where I work,
and because I want to learn about Standard IOStreams, I decided to try to
write a solution that would work with standard-conforming C++ libraries.
(The <code>pfstream</code> classes were based on the old AT&amp;T-style
IOStreams and relied on <a href='http://gcc.gnu.org/'>GCC</a>-specific
libraries.)</p>
<p>My aim is to provide class templates in the style of the standard IOStreams
that can be used with any standard-conforming compiler on a POSIX platform.
This involves writing a <code>streambuf</code> class that uses
<code>fork()</code> and the <code>exec</code> family of functions to
create a new process.</p>
<p>The advantages over the standard <code>popen()</code> function are:
<ul>
<li>Standard C++ interface. PStreams classes can be used in any code that
expects an IOStream class, giving all the advantages of type-safety and
localisation that IOStreams have over the
<code>printf()</code>/<code>scanf()</code> functions in standard C.</li>
<li>Bidirectional I/O. Implementations of <code>popen()</code> vary
between systems. Some systems use bidirectional pipes, allowing reading
and writing on the same stream, but this is not supported everywhere.
Because PStreams doesn't use <code>popen()</code> but re-implements it
at a lower level, bidirectional I/O is available on all systems.</li>
<li>Reading from the process' <code>stdout</code>. Input PStreams can read
from the process' <code>stderr</code> as well as <code>stdout</code>.</li>
<li>More flexible interface. In addition to handling a shell command in
the same way as <code>popen()</code> the PStreams classes can open a process
specified by a filename and a vector of arguments, similar to the
<code>execv()</code> function.</li>
</ul>
<p>The library is available under the <a href='http://www.gnu.org/'>GNU</a>
<a href='http://www.gnu.org/licenses/gpl.txt'>General Public License</a>

<p>&nbsp;</p>
<h2><a name='status'>Current status</a></h2>
<p>Version 0.21</p>
<p>Working <code>ipstream</code> and <code>opstream</code> classes for
ISO C++-compliant compilers.
New implementation of the stream buffer class, <code>pstreambuf</code>,
that doesn't use <code>popen()</code>. The stream buffer uses up to three
pipes shared with the associated process, giving access to any combination
of the process' <code>stdin</code>, <code>stdout</code> and <code>stderr</code>
streams.</p>
<p>No code-conversion is performed on multi-byte character streams.
It should be possible to use the PStream classes templatized with character
types other than <code>char</code> (e.g. <code>basic_pstream&lt;int&gt;</code>)
but note that characters are transfered in a bytewise manner, so it is the
programmer's responsibility to interpret the resulting character strings.
Since the classes are intended to be used to read/write data between
processes, which will usually share an internal character representation,
rather than to/from files, this behaviour should be sufficient.</p>
<p>The PStreams classes do not currently do any buffering.
This means that a call to <code>write(2)</code> or <code>read(2)</code>
is made for every character, I doubt this is very efficient!</p>
<p>For non-ISO C++-compliant compilers there are alternative versions of
all classes.
These use non-standard extensions found in the old streams
(such as attaching an <code>fstream</code>'s buffer to a file descriptor with
<code>fstreambase::attach(int fd)</code>) that may not be available on some
systems.
For GCC 2.7/2.8/2.9x/egcs these classes are functional, but are
implemented using <code>fstream</code> and provide no more functionality
than the <code>pfstream</code> classes provided with libg++.
For all other compilers these classes have never even been compiled, let
alone tested, so use them at your own risk.
<br />The non-compliant versions are defined in the pstream_compat.h file
and can be used by defining <code>BACK_COMPAT</code>
(or <code>GCC_BACK_COMPAT</code> for the libg++ versions)
to be <code>1</code>.
<br />Instantiating the backward-compatible <code>ipstream</code> or
<code>opstream</code>
currently sets <code>errno</code> to <code>ESPIPE</code> because the
<code>fstreambase</code> tries to seek to the end of the stream, which
is not allowed for pipes. <code>errno</code> is reset by the classes.</p>
<p>&nbsp;</p>
<h2><a name='usage'>Usage</a></h2>
<p class='note'>Please refer to the doxygen-generated documentation,
accessible through the links at the top of the page.</p>
<p>Using the PStreams classes is similar to using a <code>std::fstream</code>,
except that a shell command is given rather than a filename:</p>
<pre><code>
// print names of all header files in current directory
redi::ipstream in("ls ./*.h");
std::string str;
while (in &gt;&gt; str) {
    std::cout &lt;&lt; str &lt;&lt; std::endl;
}
</code></pre>
<p>The  command  argument  is  a pointer to a null-terminated
string containing a shell command line.  This  command  is
passed  to  /bin/sh  using the -c flag; interpretation, if
any, is performed by the shell.</p>
<p>Alternatively, the process can be started with a vector of arguments:</p>
<pre><code>
// remove some files, capturing any error messages
std::vector&lt;std::string&gt; argv;
std::vector&lt;std::string&gt; errors;
argv.push_back("rm");
argv.push_back("-rf");
argv.push_back("./foo.txt");
argv.push_back("./bar.html");
argv.push_back("./fnord/");
redi::ipstream in("rm", argv, pstreambuf::pstderr);
std::string errmsg;
while (std::getline(in, errmsg)) {
    errors.push_back(ermsg);
}
</code></pre>
<p>If the file argument doesn't contain a slash then the actions of the shell
will be duplicated in searching for an executable shell in <code>PATH</code>.
The shell will not interpret the other arguments, so wildcard expansion will
not take place if this interface is used.</p>

<p>&nbsp;</p>
<h2><a name='download'>Download</a></h2>
<p>The "library" currently consists of a single header file,
<a href='pstream.h'>pstream.h</a>, which defines the PStreams classes
in the <code>redi</code> namespace.</p>
<p>The backward-compatible (i.e. non-standard) PStreams classes are in the
file <a href='pstream_compat.h'>pstream_compat.h</a>.</p>
<p><a href='#top'>top</a></p>

<p>&nbsp;</p>
<h2><a name='credits'>Credits</a></h2>
<p>
Angelika langer &amp; Klaus Kreft for the invaluable examples in their book
<cite>Standard C++ IOStreams and Locales</cite>.
<br>
John Levon for comments and advice on the interface design.
<br>
Whoever who wrote the <code>ChildReader</code> class for the
<a href='http://www.lyx.org'>LyX</a> project, which was a good starting
point when replacing <code>popen()</code> with hand-rolled fork/exec code.
<br>
Per Bothner et al. for the <code>pfstream</code> classes in the old libg++.
</p>
<p><a href='#top'>top</a></p>

<hr>
<address>
<p>Please send comments, suggestions, bugfixes, patches, cakes, pies etc. to
pstreams&nbsp;at&nbsp;redi&nbsp;dot&nbsp;uklinux&nbsp;dot&nbsp;net
<br />This page last updated on $Date: 2002/04/20 20:33:52 $
<br />Copyright &copy; 2001,2002 Jonathan Wakely</p>
</address>
<p>
<a href="http://validator.w3.org/check/referer"><img
  src="http://www.w3.org/Icons/valid-html40"
  alt="Valid HTML 4.0!" height="31" width="88"></a>
<a href="http://jigsaw.w3.org/css-validator/"><img
  style="border:0;width:88px;height:31px"
  src="http://jigsaw.w3.org/css-validator/images/vcss" 
  alt="Valid CSS!"></a>
</p>

<!-- end of included file -->

